// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'widget_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$WidgetState<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() none,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        loading,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        processing,
    required TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)
        success,
    required TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)
        error,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        empty,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        allData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? none,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult? Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult? Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? none,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WidgetStateIdle<T> value) idle,
    required TResult Function(_WidgetStateNone<T> value) none,
    required TResult Function(_WidgetLoading<T> value) loading,
    required TResult Function(_WidgetProcessing<T> value) processing,
    required TResult Function(_WidgetSuccess<T> value) success,
    required TResult Function(_WidgetError<T> value) error,
    required TResult Function(_WidgetEmpty<T> value) empty,
    required TResult Function(_WidgetAllData<T> value) allData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WidgetStateIdle<T> value)? idle,
    TResult? Function(_WidgetStateNone<T> value)? none,
    TResult? Function(_WidgetLoading<T> value)? loading,
    TResult? Function(_WidgetProcessing<T> value)? processing,
    TResult? Function(_WidgetSuccess<T> value)? success,
    TResult? Function(_WidgetError<T> value)? error,
    TResult? Function(_WidgetEmpty<T> value)? empty,
    TResult? Function(_WidgetAllData<T> value)? allData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WidgetStateIdle<T> value)? idle,
    TResult Function(_WidgetStateNone<T> value)? none,
    TResult Function(_WidgetLoading<T> value)? loading,
    TResult Function(_WidgetProcessing<T> value)? processing,
    TResult Function(_WidgetSuccess<T> value)? success,
    TResult Function(_WidgetError<T> value)? error,
    TResult Function(_WidgetEmpty<T> value)? empty,
    TResult Function(_WidgetAllData<T> value)? allData,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WidgetStateCopyWith<T, $Res> {
  factory $WidgetStateCopyWith(
          WidgetState<T> value, $Res Function(WidgetState<T>) then) =
      _$WidgetStateCopyWithImpl<T, $Res, WidgetState<T>>;
}

/// @nodoc
class _$WidgetStateCopyWithImpl<T, $Res, $Val extends WidgetState<T>>
    implements $WidgetStateCopyWith<T, $Res> {
  _$WidgetStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$WidgetStateIdleImplCopyWith<T, $Res> {
  factory _$$WidgetStateIdleImplCopyWith(_$WidgetStateIdleImpl<T> value,
          $Res Function(_$WidgetStateIdleImpl<T>) then) =
      __$$WidgetStateIdleImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$WidgetStateIdleImplCopyWithImpl<T, $Res>
    extends _$WidgetStateCopyWithImpl<T, $Res, _$WidgetStateIdleImpl<T>>
    implements _$$WidgetStateIdleImplCopyWith<T, $Res> {
  __$$WidgetStateIdleImplCopyWithImpl(_$WidgetStateIdleImpl<T> _value,
      $Res Function(_$WidgetStateIdleImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WidgetStateIdleImpl<T> implements _WidgetStateIdle<T> {
  const _$WidgetStateIdleImpl();

  @override
  String toString() {
    return 'WidgetState<$T>.idle()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WidgetStateIdleImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() none,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        loading,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        processing,
    required TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)
        success,
    required TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)
        error,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        empty,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        allData,
  }) {
    return idle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? none,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult? Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult? Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
  }) {
    return idle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? none,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WidgetStateIdle<T> value) idle,
    required TResult Function(_WidgetStateNone<T> value) none,
    required TResult Function(_WidgetLoading<T> value) loading,
    required TResult Function(_WidgetProcessing<T> value) processing,
    required TResult Function(_WidgetSuccess<T> value) success,
    required TResult Function(_WidgetError<T> value) error,
    required TResult Function(_WidgetEmpty<T> value) empty,
    required TResult Function(_WidgetAllData<T> value) allData,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WidgetStateIdle<T> value)? idle,
    TResult? Function(_WidgetStateNone<T> value)? none,
    TResult? Function(_WidgetLoading<T> value)? loading,
    TResult? Function(_WidgetProcessing<T> value)? processing,
    TResult? Function(_WidgetSuccess<T> value)? success,
    TResult? Function(_WidgetError<T> value)? error,
    TResult? Function(_WidgetEmpty<T> value)? empty,
    TResult? Function(_WidgetAllData<T> value)? allData,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WidgetStateIdle<T> value)? idle,
    TResult Function(_WidgetStateNone<T> value)? none,
    TResult Function(_WidgetLoading<T> value)? loading,
    TResult Function(_WidgetProcessing<T> value)? processing,
    TResult Function(_WidgetSuccess<T> value)? success,
    TResult Function(_WidgetError<T> value)? error,
    TResult Function(_WidgetEmpty<T> value)? empty,
    TResult Function(_WidgetAllData<T> value)? allData,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class _WidgetStateIdle<T> implements WidgetState<T> {
  const factory _WidgetStateIdle() = _$WidgetStateIdleImpl<T>;
}

/// @nodoc
abstract class _$$WidgetStateNoneImplCopyWith<T, $Res> {
  factory _$$WidgetStateNoneImplCopyWith(_$WidgetStateNoneImpl<T> value,
          $Res Function(_$WidgetStateNoneImpl<T>) then) =
      __$$WidgetStateNoneImplCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$WidgetStateNoneImplCopyWithImpl<T, $Res>
    extends _$WidgetStateCopyWithImpl<T, $Res, _$WidgetStateNoneImpl<T>>
    implements _$$WidgetStateNoneImplCopyWith<T, $Res> {
  __$$WidgetStateNoneImplCopyWithImpl(_$WidgetStateNoneImpl<T> _value,
      $Res Function(_$WidgetStateNoneImpl<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WidgetStateNoneImpl<T> implements _WidgetStateNone<T> {
  const _$WidgetStateNoneImpl();

  @override
  String toString() {
    return 'WidgetState<$T>.none()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WidgetStateNoneImpl<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() none,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        loading,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        processing,
    required TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)
        success,
    required TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)
        error,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        empty,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        allData,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? none,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult? Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult? Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? none,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WidgetStateIdle<T> value) idle,
    required TResult Function(_WidgetStateNone<T> value) none,
    required TResult Function(_WidgetLoading<T> value) loading,
    required TResult Function(_WidgetProcessing<T> value) processing,
    required TResult Function(_WidgetSuccess<T> value) success,
    required TResult Function(_WidgetError<T> value) error,
    required TResult Function(_WidgetEmpty<T> value) empty,
    required TResult Function(_WidgetAllData<T> value) allData,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WidgetStateIdle<T> value)? idle,
    TResult? Function(_WidgetStateNone<T> value)? none,
    TResult? Function(_WidgetLoading<T> value)? loading,
    TResult? Function(_WidgetProcessing<T> value)? processing,
    TResult? Function(_WidgetSuccess<T> value)? success,
    TResult? Function(_WidgetError<T> value)? error,
    TResult? Function(_WidgetEmpty<T> value)? empty,
    TResult? Function(_WidgetAllData<T> value)? allData,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WidgetStateIdle<T> value)? idle,
    TResult Function(_WidgetStateNone<T> value)? none,
    TResult Function(_WidgetLoading<T> value)? loading,
    TResult Function(_WidgetProcessing<T> value)? processing,
    TResult Function(_WidgetSuccess<T> value)? success,
    TResult Function(_WidgetError<T> value)? error,
    TResult Function(_WidgetEmpty<T> value)? empty,
    TResult Function(_WidgetAllData<T> value)? allData,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class _WidgetStateNone<T> implements WidgetState<T> {
  const factory _WidgetStateNone() = _$WidgetStateNoneImpl<T>;
}

/// @nodoc
abstract class _$$WidgetLoadingImplCopyWith<T, $Res> {
  factory _$$WidgetLoadingImplCopyWith(_$WidgetLoadingImpl<T> value,
          $Res Function(_$WidgetLoadingImpl<T>) then) =
      __$$WidgetLoadingImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call(
      {BuildContext context, Widget? child, String message, dynamic isLoading});
}

/// @nodoc
class __$$WidgetLoadingImplCopyWithImpl<T, $Res>
    extends _$WidgetStateCopyWithImpl<T, $Res, _$WidgetLoadingImpl<T>>
    implements _$$WidgetLoadingImplCopyWith<T, $Res> {
  __$$WidgetLoadingImplCopyWithImpl(_$WidgetLoadingImpl<T> _value,
      $Res Function(_$WidgetLoadingImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? context = null,
    Object? child = freezed,
    Object? message = null,
    Object? isLoading = freezed,
  }) {
    return _then(_$WidgetLoadingImpl<T>(
      context: null == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as BuildContext,
      child: freezed == child
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as Widget?,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      isLoading: freezed == isLoading ? _value.isLoading! : isLoading,
    ));
  }
}

/// @nodoc

class _$WidgetLoadingImpl<T> implements _WidgetLoading<T> {
  const _$WidgetLoadingImpl(
      {required this.context,
      this.child,
      this.message = 'Loading...',
      this.isLoading = false});

  @override
  final BuildContext context;
  @override
  final Widget? child;
  @override
  @JsonKey()
  final String message;
  @override
  @JsonKey()
  final dynamic isLoading;

  @override
  String toString() {
    return 'WidgetState<$T>.loading(context: $context, child: $child, message: $message, isLoading: $isLoading)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WidgetLoadingImpl<T> &&
            (identical(other.context, context) || other.context == context) &&
            (identical(other.child, child) || other.child == child) &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other.isLoading, isLoading));
  }

  @override
  int get hashCode => Object.hash(runtimeType, context, child, message,
      const DeepCollectionEquality().hash(isLoading));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WidgetLoadingImplCopyWith<T, _$WidgetLoadingImpl<T>> get copyWith =>
      __$$WidgetLoadingImplCopyWithImpl<T, _$WidgetLoadingImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() none,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        loading,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        processing,
    required TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)
        success,
    required TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)
        error,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        empty,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        allData,
  }) {
    return loading(context, child, message, isLoading);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? none,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult? Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult? Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
  }) {
    return loading?.call(context, child, message, isLoading);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? none,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(context, child, message, isLoading);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WidgetStateIdle<T> value) idle,
    required TResult Function(_WidgetStateNone<T> value) none,
    required TResult Function(_WidgetLoading<T> value) loading,
    required TResult Function(_WidgetProcessing<T> value) processing,
    required TResult Function(_WidgetSuccess<T> value) success,
    required TResult Function(_WidgetError<T> value) error,
    required TResult Function(_WidgetEmpty<T> value) empty,
    required TResult Function(_WidgetAllData<T> value) allData,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WidgetStateIdle<T> value)? idle,
    TResult? Function(_WidgetStateNone<T> value)? none,
    TResult? Function(_WidgetLoading<T> value)? loading,
    TResult? Function(_WidgetProcessing<T> value)? processing,
    TResult? Function(_WidgetSuccess<T> value)? success,
    TResult? Function(_WidgetError<T> value)? error,
    TResult? Function(_WidgetEmpty<T> value)? empty,
    TResult? Function(_WidgetAllData<T> value)? allData,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WidgetStateIdle<T> value)? idle,
    TResult Function(_WidgetStateNone<T> value)? none,
    TResult Function(_WidgetLoading<T> value)? loading,
    TResult Function(_WidgetProcessing<T> value)? processing,
    TResult Function(_WidgetSuccess<T> value)? success,
    TResult Function(_WidgetError<T> value)? error,
    TResult Function(_WidgetEmpty<T> value)? empty,
    TResult Function(_WidgetAllData<T> value)? allData,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _WidgetLoading<T> implements WidgetState<T> {
  const factory _WidgetLoading(
      {required final BuildContext context,
      final Widget? child,
      final String message,
      final dynamic isLoading}) = _$WidgetLoadingImpl<T>;

  BuildContext get context;
  Widget? get child;
  String get message;
  dynamic get isLoading;
  @JsonKey(ignore: true)
  _$$WidgetLoadingImplCopyWith<T, _$WidgetLoadingImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WidgetProcessingImplCopyWith<T, $Res> {
  factory _$$WidgetProcessingImplCopyWith(_$WidgetProcessingImpl<T> value,
          $Res Function(_$WidgetProcessingImpl<T>) then) =
      __$$WidgetProcessingImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call(
      {BuildContext context, Widget? child, String message, dynamic isLoading});
}

/// @nodoc
class __$$WidgetProcessingImplCopyWithImpl<T, $Res>
    extends _$WidgetStateCopyWithImpl<T, $Res, _$WidgetProcessingImpl<T>>
    implements _$$WidgetProcessingImplCopyWith<T, $Res> {
  __$$WidgetProcessingImplCopyWithImpl(_$WidgetProcessingImpl<T> _value,
      $Res Function(_$WidgetProcessingImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? context = null,
    Object? child = freezed,
    Object? message = null,
    Object? isLoading = freezed,
  }) {
    return _then(_$WidgetProcessingImpl<T>(
      context: null == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as BuildContext,
      child: freezed == child
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as Widget?,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      isLoading: freezed == isLoading ? _value.isLoading! : isLoading,
    ));
  }
}

/// @nodoc

class _$WidgetProcessingImpl<T> implements _WidgetProcessing<T> {
  const _$WidgetProcessingImpl(
      {required this.context,
      this.child,
      this.message = 'Loading...',
      this.isLoading = false});

  @override
  final BuildContext context;
  @override
  final Widget? child;
  @override
  @JsonKey()
  final String message;
  @override
  @JsonKey()
  final dynamic isLoading;

  @override
  String toString() {
    return 'WidgetState<$T>.processing(context: $context, child: $child, message: $message, isLoading: $isLoading)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WidgetProcessingImpl<T> &&
            (identical(other.context, context) || other.context == context) &&
            (identical(other.child, child) || other.child == child) &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other.isLoading, isLoading));
  }

  @override
  int get hashCode => Object.hash(runtimeType, context, child, message,
      const DeepCollectionEquality().hash(isLoading));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WidgetProcessingImplCopyWith<T, _$WidgetProcessingImpl<T>> get copyWith =>
      __$$WidgetProcessingImplCopyWithImpl<T, _$WidgetProcessingImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() none,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        loading,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        processing,
    required TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)
        success,
    required TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)
        error,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        empty,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        allData,
  }) {
    return processing(context, child, message, isLoading);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? none,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult? Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult? Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
  }) {
    return processing?.call(context, child, message, isLoading);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? none,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
    required TResult orElse(),
  }) {
    if (processing != null) {
      return processing(context, child, message, isLoading);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WidgetStateIdle<T> value) idle,
    required TResult Function(_WidgetStateNone<T> value) none,
    required TResult Function(_WidgetLoading<T> value) loading,
    required TResult Function(_WidgetProcessing<T> value) processing,
    required TResult Function(_WidgetSuccess<T> value) success,
    required TResult Function(_WidgetError<T> value) error,
    required TResult Function(_WidgetEmpty<T> value) empty,
    required TResult Function(_WidgetAllData<T> value) allData,
  }) {
    return processing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WidgetStateIdle<T> value)? idle,
    TResult? Function(_WidgetStateNone<T> value)? none,
    TResult? Function(_WidgetLoading<T> value)? loading,
    TResult? Function(_WidgetProcessing<T> value)? processing,
    TResult? Function(_WidgetSuccess<T> value)? success,
    TResult? Function(_WidgetError<T> value)? error,
    TResult? Function(_WidgetEmpty<T> value)? empty,
    TResult? Function(_WidgetAllData<T> value)? allData,
  }) {
    return processing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WidgetStateIdle<T> value)? idle,
    TResult Function(_WidgetStateNone<T> value)? none,
    TResult Function(_WidgetLoading<T> value)? loading,
    TResult Function(_WidgetProcessing<T> value)? processing,
    TResult Function(_WidgetSuccess<T> value)? success,
    TResult Function(_WidgetError<T> value)? error,
    TResult Function(_WidgetEmpty<T> value)? empty,
    TResult Function(_WidgetAllData<T> value)? allData,
    required TResult orElse(),
  }) {
    if (processing != null) {
      return processing(this);
    }
    return orElse();
  }
}

abstract class _WidgetProcessing<T> implements WidgetState<T> {
  const factory _WidgetProcessing(
      {required final BuildContext context,
      final Widget? child,
      final String message,
      final dynamic isLoading}) = _$WidgetProcessingImpl<T>;

  BuildContext get context;
  Widget? get child;
  String get message;
  dynamic get isLoading;
  @JsonKey(ignore: true)
  _$$WidgetProcessingImplCopyWith<T, _$WidgetProcessingImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WidgetSuccessImplCopyWith<T, $Res> {
  factory _$$WidgetSuccessImplCopyWith(_$WidgetSuccessImpl<T> value,
          $Res Function(_$WidgetSuccessImpl<T>) then) =
      __$$WidgetSuccessImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call(
      {BuildContext context,
      Widget? child,
      T data,
      Map<String, dynamic> otherData});
}

/// @nodoc
class __$$WidgetSuccessImplCopyWithImpl<T, $Res>
    extends _$WidgetStateCopyWithImpl<T, $Res, _$WidgetSuccessImpl<T>>
    implements _$$WidgetSuccessImplCopyWith<T, $Res> {
  __$$WidgetSuccessImplCopyWithImpl(_$WidgetSuccessImpl<T> _value,
      $Res Function(_$WidgetSuccessImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? context = null,
    Object? child = freezed,
    Object? data = freezed,
    Object? otherData = null,
  }) {
    return _then(_$WidgetSuccessImpl<T>(
      context: null == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as BuildContext,
      child: freezed == child
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as Widget?,
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as T,
      otherData: null == otherData
          ? _value._otherData
          : otherData // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc

class _$WidgetSuccessImpl<T> implements _WidgetSuccess<T> {
  const _$WidgetSuccessImpl(
      {required this.context,
      this.child,
      required this.data,
      final Map<String, dynamic> otherData = const {}})
      : _otherData = otherData;

  @override
  final BuildContext context;
  @override
  final Widget? child;
  @override
  final T data;
  final Map<String, dynamic> _otherData;
  @override
  @JsonKey()
  Map<String, dynamic> get otherData {
    if (_otherData is EqualUnmodifiableMapView) return _otherData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_otherData);
  }

  @override
  String toString() {
    return 'WidgetState<$T>.success(context: $context, child: $child, data: $data, otherData: $otherData)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WidgetSuccessImpl<T> &&
            (identical(other.context, context) || other.context == context) &&
            (identical(other.child, child) || other.child == child) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            const DeepCollectionEquality()
                .equals(other._otherData, _otherData));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      context,
      child,
      const DeepCollectionEquality().hash(data),
      const DeepCollectionEquality().hash(_otherData));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WidgetSuccessImplCopyWith<T, _$WidgetSuccessImpl<T>> get copyWith =>
      __$$WidgetSuccessImplCopyWithImpl<T, _$WidgetSuccessImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() none,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        loading,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        processing,
    required TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)
        success,
    required TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)
        error,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        empty,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        allData,
  }) {
    return success(context, child, data, otherData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? none,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult? Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult? Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
  }) {
    return success?.call(context, child, data, otherData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? none,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(context, child, data, otherData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WidgetStateIdle<T> value) idle,
    required TResult Function(_WidgetStateNone<T> value) none,
    required TResult Function(_WidgetLoading<T> value) loading,
    required TResult Function(_WidgetProcessing<T> value) processing,
    required TResult Function(_WidgetSuccess<T> value) success,
    required TResult Function(_WidgetError<T> value) error,
    required TResult Function(_WidgetEmpty<T> value) empty,
    required TResult Function(_WidgetAllData<T> value) allData,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WidgetStateIdle<T> value)? idle,
    TResult? Function(_WidgetStateNone<T> value)? none,
    TResult? Function(_WidgetLoading<T> value)? loading,
    TResult? Function(_WidgetProcessing<T> value)? processing,
    TResult? Function(_WidgetSuccess<T> value)? success,
    TResult? Function(_WidgetError<T> value)? error,
    TResult? Function(_WidgetEmpty<T> value)? empty,
    TResult? Function(_WidgetAllData<T> value)? allData,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WidgetStateIdle<T> value)? idle,
    TResult Function(_WidgetStateNone<T> value)? none,
    TResult Function(_WidgetLoading<T> value)? loading,
    TResult Function(_WidgetProcessing<T> value)? processing,
    TResult Function(_WidgetSuccess<T> value)? success,
    TResult Function(_WidgetError<T> value)? error,
    TResult Function(_WidgetEmpty<T> value)? empty,
    TResult Function(_WidgetAllData<T> value)? allData,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _WidgetSuccess<T> implements WidgetState<T> {
  const factory _WidgetSuccess(
      {required final BuildContext context,
      final Widget? child,
      required final T data,
      final Map<String, dynamic> otherData}) = _$WidgetSuccessImpl<T>;

  BuildContext get context;
  Widget? get child;
  T get data;
  Map<String, dynamic> get otherData;
  @JsonKey(ignore: true)
  _$$WidgetSuccessImplCopyWith<T, _$WidgetSuccessImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WidgetErrorImplCopyWith<T, $Res> {
  factory _$$WidgetErrorImplCopyWith(_$WidgetErrorImpl<T> value,
          $Res Function(_$WidgetErrorImpl<T>) then) =
      __$$WidgetErrorImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call(
      {BuildContext context,
      Widget? child,
      String reason,
      Object? error,
      NetworkException? networkException,
      StackTrace? stackTrace});

  $NetworkExceptionCopyWith<$Res>? get networkException;
}

/// @nodoc
class __$$WidgetErrorImplCopyWithImpl<T, $Res>
    extends _$WidgetStateCopyWithImpl<T, $Res, _$WidgetErrorImpl<T>>
    implements _$$WidgetErrorImplCopyWith<T, $Res> {
  __$$WidgetErrorImplCopyWithImpl(
      _$WidgetErrorImpl<T> _value, $Res Function(_$WidgetErrorImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? context = null,
    Object? child = freezed,
    Object? reason = null,
    Object? error = freezed,
    Object? networkException = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$WidgetErrorImpl<T>(
      context: null == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as BuildContext,
      child: freezed == child
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as Widget?,
      reason: null == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as String,
      error: freezed == error ? _value.error : error,
      networkException: freezed == networkException
          ? _value.networkException
          : networkException // ignore: cast_nullable_to_non_nullable
              as NetworkException?,
      stackTrace: freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NetworkExceptionCopyWith<$Res>? get networkException {
    if (_value.networkException == null) {
      return null;
    }

    return $NetworkExceptionCopyWith<$Res>(_value.networkException!, (value) {
      return _then(_value.copyWith(networkException: value));
    });
  }
}

/// @nodoc

class _$WidgetErrorImpl<T> implements _WidgetError<T> {
  const _$WidgetErrorImpl(
      {required this.context,
      this.child,
      required this.reason,
      this.error,
      this.networkException,
      this.stackTrace});

  @override
  final BuildContext context;
  @override
  final Widget? child;
  @override
  final String reason;
  @override
  final Object? error;
  @override
  final NetworkException? networkException;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'WidgetState<$T>.error(context: $context, child: $child, reason: $reason, error: $error, networkException: $networkException, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WidgetErrorImpl<T> &&
            (identical(other.context, context) || other.context == context) &&
            (identical(other.child, child) || other.child == child) &&
            (identical(other.reason, reason) || other.reason == reason) &&
            const DeepCollectionEquality().equals(other.error, error) &&
            (identical(other.networkException, networkException) ||
                other.networkException == networkException) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(runtimeType, context, child, reason,
      const DeepCollectionEquality().hash(error), networkException, stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WidgetErrorImplCopyWith<T, _$WidgetErrorImpl<T>> get copyWith =>
      __$$WidgetErrorImplCopyWithImpl<T, _$WidgetErrorImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() none,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        loading,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        processing,
    required TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)
        success,
    required TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)
        error,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        empty,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        allData,
  }) {
    return error(
        context, child, reason, this.error, networkException, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? none,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult? Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult? Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
  }) {
    return error?.call(
        context, child, reason, this.error, networkException, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? none,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(
          context, child, reason, this.error, networkException, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WidgetStateIdle<T> value) idle,
    required TResult Function(_WidgetStateNone<T> value) none,
    required TResult Function(_WidgetLoading<T> value) loading,
    required TResult Function(_WidgetProcessing<T> value) processing,
    required TResult Function(_WidgetSuccess<T> value) success,
    required TResult Function(_WidgetError<T> value) error,
    required TResult Function(_WidgetEmpty<T> value) empty,
    required TResult Function(_WidgetAllData<T> value) allData,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WidgetStateIdle<T> value)? idle,
    TResult? Function(_WidgetStateNone<T> value)? none,
    TResult? Function(_WidgetLoading<T> value)? loading,
    TResult? Function(_WidgetProcessing<T> value)? processing,
    TResult? Function(_WidgetSuccess<T> value)? success,
    TResult? Function(_WidgetError<T> value)? error,
    TResult? Function(_WidgetEmpty<T> value)? empty,
    TResult? Function(_WidgetAllData<T> value)? allData,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WidgetStateIdle<T> value)? idle,
    TResult Function(_WidgetStateNone<T> value)? none,
    TResult Function(_WidgetLoading<T> value)? loading,
    TResult Function(_WidgetProcessing<T> value)? processing,
    TResult Function(_WidgetSuccess<T> value)? success,
    TResult Function(_WidgetError<T> value)? error,
    TResult Function(_WidgetEmpty<T> value)? empty,
    TResult Function(_WidgetAllData<T> value)? allData,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _WidgetError<T> implements WidgetState<T> {
  const factory _WidgetError(
      {required final BuildContext context,
      final Widget? child,
      required final String reason,
      final Object? error,
      final NetworkException? networkException,
      final StackTrace? stackTrace}) = _$WidgetErrorImpl<T>;

  BuildContext get context;
  Widget? get child;
  String get reason;
  Object? get error;
  NetworkException? get networkException;
  StackTrace? get stackTrace;
  @JsonKey(ignore: true)
  _$$WidgetErrorImplCopyWith<T, _$WidgetErrorImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WidgetEmptyImplCopyWith<T, $Res> {
  factory _$$WidgetEmptyImplCopyWith(_$WidgetEmptyImpl<T> value,
          $Res Function(_$WidgetEmptyImpl<T>) then) =
      __$$WidgetEmptyImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call(
      {BuildContext context, Widget? child, String message, List<T> data});
}

/// @nodoc
class __$$WidgetEmptyImplCopyWithImpl<T, $Res>
    extends _$WidgetStateCopyWithImpl<T, $Res, _$WidgetEmptyImpl<T>>
    implements _$$WidgetEmptyImplCopyWith<T, $Res> {
  __$$WidgetEmptyImplCopyWithImpl(
      _$WidgetEmptyImpl<T> _value, $Res Function(_$WidgetEmptyImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? context = null,
    Object? child = freezed,
    Object? message = null,
    Object? data = null,
  }) {
    return _then(_$WidgetEmptyImpl<T>(
      context: null == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as BuildContext,
      child: freezed == child
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as Widget?,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<T>,
    ));
  }
}

/// @nodoc

class _$WidgetEmptyImpl<T> implements _WidgetEmpty<T> {
  const _$WidgetEmptyImpl(
      {required this.context,
      this.child,
      this.message = 'Empty',
      final List<T> data = const []})
      : _data = data;

  @override
  final BuildContext context;
  @override
  final Widget? child;
  @override
  @JsonKey()
  final String message;
  final List<T> _data;
  @override
  @JsonKey()
  List<T> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'WidgetState<$T>.empty(context: $context, child: $child, message: $message, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WidgetEmptyImpl<T> &&
            (identical(other.context, context) || other.context == context) &&
            (identical(other.child, child) || other.child == child) &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, context, child, message,
      const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WidgetEmptyImplCopyWith<T, _$WidgetEmptyImpl<T>> get copyWith =>
      __$$WidgetEmptyImplCopyWithImpl<T, _$WidgetEmptyImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() none,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        loading,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        processing,
    required TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)
        success,
    required TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)
        error,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        empty,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        allData,
  }) {
    return empty(context, child, message, data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? none,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult? Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult? Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
  }) {
    return empty?.call(context, child, message, data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? none,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(context, child, message, data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WidgetStateIdle<T> value) idle,
    required TResult Function(_WidgetStateNone<T> value) none,
    required TResult Function(_WidgetLoading<T> value) loading,
    required TResult Function(_WidgetProcessing<T> value) processing,
    required TResult Function(_WidgetSuccess<T> value) success,
    required TResult Function(_WidgetError<T> value) error,
    required TResult Function(_WidgetEmpty<T> value) empty,
    required TResult Function(_WidgetAllData<T> value) allData,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WidgetStateIdle<T> value)? idle,
    TResult? Function(_WidgetStateNone<T> value)? none,
    TResult? Function(_WidgetLoading<T> value)? loading,
    TResult? Function(_WidgetProcessing<T> value)? processing,
    TResult? Function(_WidgetSuccess<T> value)? success,
    TResult? Function(_WidgetError<T> value)? error,
    TResult? Function(_WidgetEmpty<T> value)? empty,
    TResult? Function(_WidgetAllData<T> value)? allData,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WidgetStateIdle<T> value)? idle,
    TResult Function(_WidgetStateNone<T> value)? none,
    TResult Function(_WidgetLoading<T> value)? loading,
    TResult Function(_WidgetProcessing<T> value)? processing,
    TResult Function(_WidgetSuccess<T> value)? success,
    TResult Function(_WidgetError<T> value)? error,
    TResult Function(_WidgetEmpty<T> value)? empty,
    TResult Function(_WidgetAllData<T> value)? allData,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class _WidgetEmpty<T> implements WidgetState<T> {
  const factory _WidgetEmpty(
      {required final BuildContext context,
      final Widget? child,
      final String message,
      final List<T> data}) = _$WidgetEmptyImpl<T>;

  BuildContext get context;
  Widget? get child;
  String get message;
  List<T> get data;
  @JsonKey(ignore: true)
  _$$WidgetEmptyImplCopyWith<T, _$WidgetEmptyImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WidgetAllDataImplCopyWith<T, $Res> {
  factory _$$WidgetAllDataImplCopyWith(_$WidgetAllDataImpl<T> value,
          $Res Function(_$WidgetAllDataImpl<T>) then) =
      __$$WidgetAllDataImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call(
      {BuildContext context, Widget? child, String message, List<T> data});
}

/// @nodoc
class __$$WidgetAllDataImplCopyWithImpl<T, $Res>
    extends _$WidgetStateCopyWithImpl<T, $Res, _$WidgetAllDataImpl<T>>
    implements _$$WidgetAllDataImplCopyWith<T, $Res> {
  __$$WidgetAllDataImplCopyWithImpl(_$WidgetAllDataImpl<T> _value,
      $Res Function(_$WidgetAllDataImpl<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? context = null,
    Object? child = freezed,
    Object? message = null,
    Object? data = null,
  }) {
    return _then(_$WidgetAllDataImpl<T>(
      context: null == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as BuildContext,
      child: freezed == child
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as Widget?,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<T>,
    ));
  }
}

/// @nodoc

class _$WidgetAllDataImpl<T> implements _WidgetAllData<T> {
  const _$WidgetAllDataImpl(
      {required this.context,
      this.child,
      this.message = 'All Data',
      final List<T> data = const []})
      : _data = data;

  @override
  final BuildContext context;
  @override
  final Widget? child;
  @override
  @JsonKey()
  final String message;
  final List<T> _data;
  @override
  @JsonKey()
  List<T> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'WidgetState<$T>.allData(context: $context, child: $child, message: $message, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WidgetAllDataImpl<T> &&
            (identical(other.context, context) || other.context == context) &&
            (identical(other.child, child) || other.child == child) &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, context, child, message,
      const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WidgetAllDataImplCopyWith<T, _$WidgetAllDataImpl<T>> get copyWith =>
      __$$WidgetAllDataImplCopyWithImpl<T, _$WidgetAllDataImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() none,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        loading,
    required TResult Function(BuildContext context, Widget? child,
            String message, dynamic isLoading)
        processing,
    required TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)
        success,
    required TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)
        error,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        empty,
    required TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)
        allData,
  }) {
    return allData(context, child, message, data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? none,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult? Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult? Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult? Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult? Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
  }) {
    return allData?.call(context, child, message, data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? none,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        loading,
    TResult Function(BuildContext context, Widget? child, String message,
            dynamic isLoading)?
        processing,
    TResult Function(BuildContext context, Widget? child, T data,
            Map<String, dynamic> otherData)?
        success,
    TResult Function(
            BuildContext context,
            Widget? child,
            String reason,
            Object? error,
            NetworkException? networkException,
            StackTrace? stackTrace)?
        error,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        empty,
    TResult Function(
            BuildContext context, Widget? child, String message, List<T> data)?
        allData,
    required TResult orElse(),
  }) {
    if (allData != null) {
      return allData(context, child, message, data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WidgetStateIdle<T> value) idle,
    required TResult Function(_WidgetStateNone<T> value) none,
    required TResult Function(_WidgetLoading<T> value) loading,
    required TResult Function(_WidgetProcessing<T> value) processing,
    required TResult Function(_WidgetSuccess<T> value) success,
    required TResult Function(_WidgetError<T> value) error,
    required TResult Function(_WidgetEmpty<T> value) empty,
    required TResult Function(_WidgetAllData<T> value) allData,
  }) {
    return allData(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WidgetStateIdle<T> value)? idle,
    TResult? Function(_WidgetStateNone<T> value)? none,
    TResult? Function(_WidgetLoading<T> value)? loading,
    TResult? Function(_WidgetProcessing<T> value)? processing,
    TResult? Function(_WidgetSuccess<T> value)? success,
    TResult? Function(_WidgetError<T> value)? error,
    TResult? Function(_WidgetEmpty<T> value)? empty,
    TResult? Function(_WidgetAllData<T> value)? allData,
  }) {
    return allData?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WidgetStateIdle<T> value)? idle,
    TResult Function(_WidgetStateNone<T> value)? none,
    TResult Function(_WidgetLoading<T> value)? loading,
    TResult Function(_WidgetProcessing<T> value)? processing,
    TResult Function(_WidgetSuccess<T> value)? success,
    TResult Function(_WidgetError<T> value)? error,
    TResult Function(_WidgetEmpty<T> value)? empty,
    TResult Function(_WidgetAllData<T> value)? allData,
    required TResult orElse(),
  }) {
    if (allData != null) {
      return allData(this);
    }
    return orElse();
  }
}

abstract class _WidgetAllData<T> implements WidgetState<T> {
  const factory _WidgetAllData(
      {required final BuildContext context,
      final Widget? child,
      final String message,
      final List<T> data}) = _$WidgetAllDataImpl<T>;

  BuildContext get context;
  Widget? get child;
  String get message;
  List<T> get data;
  @JsonKey(ignore: true)
  _$$WidgetAllDataImplCopyWith<T, _$WidgetAllDataImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
